-- | Reference test-suite against parse trees generated by
-- SpiderMonkey Parser API
module Test.Reference where

import qualified Data.ByteString.Lazy as LBS
import Test.Tasty
import Test.Tasty.Golden.Advanced
import System.Directory
import qualified System.FilePath as FP
import System.IO hiding (utf8)
import Control.Monad
import Control.Monad.IO.Class
import Control.Applicative
import Data.Maybe
import Language.ECMAScript5.Parser
import Language.ECMAScript5.ParserState
import Language.ECMAScript5.Syntax
import Language.ECMAScript5.Syntax.Annotations
--import Language.ECMAScript5.SourceDiff
import Text.Groom
import Data.Algorithm.Diff
import Data.Algorithm.DiffOutput

casesDir = "test-data/t262/"

test_reference :: IO TestTree
test_reference =
  let getValid ext = filter $ \x -> FP.takeExtension x == '.':ext in
  do casesDirExists <- doesDirectoryExist casesDir
     fns <- if casesDirExists then listDirectory casesDir
            else return []
     let validCases   = getValid "js" fns
     let validExpects = getValid "parse" fns
     return $ testGroup "Parser reference test-suite" $ map genTest $ filter
       (\f -> (FP.dropExtension f) `elem` (map FP.dropExtension validExpects)) validCases


genTest :: FilePath -> TestTree
genTest test =
  let caseFileName = casesDir `FP.combine` test
      parseTreeFileName = casesDir `FP.combine` (FP.replaceExtension test ".parse")
      loadParseTree :: IO (Maybe (Program SrcLoc))
      loadParseTree = liftIO $ liftM read $ readFile parseTreeFileName
      parseCase     :: IO (Maybe (Program SrcLoc))
      parseCase     = liftIO $ liftM (either (const Nothing) (Just . reannotate (toSrcLoc . fst)) . parse program caseFileName) $ readFile caseFileName 
  in  goldenTest test loadParseTree parseCase verifyOutput (const $ return ())

verifyOutput :: Maybe (Program SrcLoc) -> Maybe (Program SrcLoc) -> IO (Maybe String)
verifyOutput expected actual =
  let plines = lines . groom
      dexp :: Maybe (Program ())
      dexp  = removeAnnotations <$> expected
      dact :: Maybe (Program ())
      dact  = removeAnnotations <$> actual
  in if dexp == dact then return Nothing
     else return $ Just $ ppDiff $ getGroupedDiff (plines dexp) (plines dact)

noSrcFile (SrcLoc (a,b,c,d,_)) = SrcLoc (a,b,c,d,Nothing)
noSrcFile NoLoc = NoLoc
